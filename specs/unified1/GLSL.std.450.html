<!DOCTYPE html>
<html lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="generator" content="AsciiDoc 8.6.9">
<title>SPIR-V Extended Instructions for GLSL</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Arial,sans-serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


@media screen {
  body {
    max-width: 50em; /* approximately 80 characters wide */
    margin-left: 16em;
  }

  #toc {
    position: fixed;
    top: 0;
    left: 0;
    bottom: 0;
    width: 13em;
    padding: 0.5em;
    padding-bottom: 1.5em;
    margin: 0;
    overflow: auto;
    border-right: 3px solid #f8f8f8;
    background-color: white;
  }

  #toc .toclevel1 {
    margin-top: 0.25em;
    font-weight: bold;
  }

  #toc .toclevel2 {
    margin-top: 0.25em;
    margin-left: 1em;
    color: #aaaaaa;
  }

  #toc .toclevel3 {
    margin-top: 0.25em;
    margin-left: 2em;
    color: #aaaaaa;
    font-size: smaller;
  }

  #toctitle {
    margin-top: 0.5em;
  }
}
</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(3);
/*]]>*/
</script>
<script type="text/javascript">
/*<![CDATA[*/
/*
ASCIIMathML.js
==============
This file contains JavaScript functions to convert ASCII math notation
to Presentation MathML. The conversion is done while the (X)HTML page
loads, and should work with Firefox/Mozilla/Netscape 7+ and Internet
Explorer 6+MathPlayer (http://www.dessci.com/en/products/mathplayer/).
Just add the next line to your (X)HTML page with this file in the same folder:
This is a convenient and inexpensive solution for authoring MathML.

Version 1.4.7 Dec 15, 2005, (c) Peter Jipsen http://www.chapman.edu/~jipsen
Latest version at http://www.chapman.edu/~jipsen/mathml/ASCIIMathML.js
For changes see http://www.chapman.edu/~jipsen/mathml/asciimathchanges.txt
If you use it on a webpage, please send the URL to jipsen@chapman.edu

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License (at http://www.gnu.org/copyleft/gpl.html)
for more details.
*/

var checkForMathML = true;   // check if browser can display MathML
var notifyIfNoMathML = true; // display note if no MathML capability
var alertIfNoMathML = false;  // show alert box if no MathML capability
var mathcolor = "";       // change it to "" (to inherit) or any other color
var mathfontfamily = "serif"; // change to "" to inherit (works in IE)
                              // or another family (e.g. "arial")
var displaystyle = true;      // puts limits above and below large operators
var showasciiformulaonhover = true; // helps students learn ASCIIMath
var decimalsign = ".";        // change to "," if you like, beware of `(1,2)`!
var AMdelimiter1 = "`", AMescape1 = "\\\\`"; // can use other characters
var AMdelimiter2 = "$", AMescape2 = "\\\\\\$", AMdelimiter2regexp = "\\$";
var doubleblankmathdelimiter = false; // if true,  x+1  is equal to `x+1`
                                      // for IE this works only in <!--   -->
//var separatetokens;// has been removed (email me if this is a problem)
var isIE = document.createElementNS==null;

if (document.getElementById==null)
  alert("This webpage requires a recent browser such as\
\nMozilla/Netscape 7+ or Internet Explorer 6+MathPlayer")

// all further global variables start with "AM"

function AMcreateElementXHTML(t) {
  if (isIE) return document.createElement(t);
  else return document.createElementNS("http://www.w3.org/1999/xhtml",t);
}

function AMnoMathMLNote() {
  var nd = AMcreateElementXHTML("h3");
  nd.setAttribute("align","center")
  nd.appendChild(AMcreateElementXHTML("p"));
  nd.appendChild(document.createTextNode("To view the "));
  var an = AMcreateElementXHTML("a");
  an.appendChild(document.createTextNode("ASCIIMathML"));
  an.setAttribute("href","http://www.chapman.edu/~jipsen/asciimath.html");
  nd.appendChild(an);
  nd.appendChild(document.createTextNode(" notation use Internet Explorer 6+"));
  an = AMcreateElementXHTML("a");
  an.appendChild(document.createTextNode("MathPlayer"));
  an.setAttribute("href","http://www.dessci.com/en/products/mathplayer/download.htm");
  nd.appendChild(an);
  nd.appendChild(document.createTextNode(" or Netscape/Mozilla/Firefox"));
  nd.appendChild(AMcreateElementXHTML("p"));
  return nd;
}

function AMisMathMLavailable() {
  if (navigator.appName.slice(0,8)=="Netscape")
    if (navigator.appVersion.slice(0,1)>="5") return null;
    else return AMnoMathMLNote();
  else if (navigator.appName.slice(0,9)=="Microsoft")
    try {
        var ActiveX = new ActiveXObject("MathPlayer.Factory.1");
        return null;
    } catch (e) {
        return AMnoMathMLNote();
    }
  else return AMnoMathMLNote();
}

// character lists for Mozilla/Netscape fonts
var AMcal = [0xEF35,0x212C,0xEF36,0xEF37,0x2130,0x2131,0xEF38,0x210B,0x2110,0xEF39,0xEF3A,0x2112,0x2133,0xEF3B,0xEF3C,0xEF3D,0xEF3E,0x211B,0xEF3F,0xEF40,0xEF41,0xEF42,0xEF43,0xEF44,0xEF45,0xEF46];
var AMfrk = [0xEF5D,0xEF5E,0x212D,0xEF5F,0xEF60,0xEF61,0xEF62,0x210C,0x2111,0xEF63,0xEF64,0xEF65,0xEF66,0xEF67,0xEF68,0xEF69,0xEF6A,0x211C,0xEF6B,0xEF6C,0xEF6D,0xEF6E,0xEF6F,0xEF70,0xEF71,0x2128];
var AMbbb = [0xEF8C,0xEF8D,0x2102,0xEF8E,0xEF8F,0xEF90,0xEF91,0x210D,0xEF92,0xEF93,0xEF94,0xEF95,0xEF96,0x2115,0xEF97,0x2119,0x211A,0x211D,0xEF98,0xEF99,0xEF9A,0xEF9B,0xEF9C,0xEF9D,0xEF9E,0x2124];

var CONST = 0, UNARY = 1, BINARY = 2, INFIX = 3, LEFTBRACKET = 4,
    RIGHTBRACKET = 5, SPACE = 6, UNDEROVER = 7, DEFINITION = 8,
    LEFTRIGHT = 9, TEXT = 10; // token types

var AMsqrt = {input:"sqrt", tag:"msqrt", output:"sqrt", tex:null, ttype:UNARY},
  AMroot  = {input:"root", tag:"mroot", output:"root", tex:null, ttype:BINARY},
  AMfrac  = {input:"frac", tag:"mfrac", output:"/",    tex:null, ttype:BINARY},
  AMdiv   = {input:"/",    tag:"mfrac", output:"/",    tex:null, ttype:INFIX},
  AMover  = {input:"stackrel", tag:"mover", output:"stackrel", tex:null, ttype:BINARY},
  AMsub   = {input:"_",    tag:"msub",  output:"_",    tex:null, ttype:INFIX},
  AMsup   = {input:"^",    tag:"msup",  output:"^",    tex:null, ttype:INFIX},
  AMtext  = {input:"text", tag:"mtext", output:"text", tex:null, ttype:TEXT},
  AMmbox  = {input:"mbox", tag:"mtext", output:"mbox", tex:null, ttype:TEXT},
  AMquote = {input:"\"",   tag:"mtext", output:"mbox", tex:null, ttype:TEXT};

var AMsymbols = [
//some greek symbols
{input:"alpha",  tag:"mi", output:"\u03B1", tex:null, ttype:CONST},
{input:"beta",   tag:"mi", output:"\u03B2", tex:null, ttype:CONST},
{input:"chi",    tag:"mi", output:"\u03C7", tex:null, ttype:CONST},
{input:"delta",  tag:"mi", output:"\u03B4", tex:null, ttype:CONST},
{input:"Delta",  tag:"mo", output:"\u0394", tex:null, ttype:CONST},
{input:"epsi",   tag:"mi", output:"\u03B5", tex:"epsilon", ttype:CONST},
{input:"varepsilon", tag:"mi", output:"\u025B", tex:null, ttype:CONST},
{input:"eta",    tag:"mi", output:"\u03B7", tex:null, ttype:CONST},
{input:"gamma",  tag:"mi", output:"\u03B3", tex:null, ttype:CONST},
{input:"Gamma",  tag:"mo", output:"\u0393", tex:null, ttype:CONST},
{input:"iota",   tag:"mi", output:"\u03B9", tex:null, ttype:CONST},
{input:"kappa",  tag:"mi", output:"\u03BA", tex:null, ttype:CONST},
{input:"lambda", tag:"mi", output:"\u03BB", tex:null, ttype:CONST},
{input:"Lambda", tag:"mo", output:"\u039B", tex:null, ttype:CONST},
{input:"mu",     tag:"mi", output:"\u03BC", tex:null, ttype:CONST},
{input:"nu",     tag:"mi", output:"\u03BD", tex:null, ttype:CONST},
{input:"omega",  tag:"mi", output:"\u03C9", tex:null, ttype:CONST},
{input:"Omega",  tag:"mo", output:"\u03A9", tex:null, ttype:CONST},
{input:"phi",    tag:"mi", output:"\u03C6", tex:null, ttype:CONST},
{input:"varphi", tag:"mi", output:"\u03D5", tex:null, ttype:CONST},
{input:"Phi",    tag:"mo", output:"\u03A6", tex:null, ttype:CONST},
{input:"pi",     tag:"mi", output:"\u03C0", tex:null, ttype:CONST},
{input:"Pi",     tag:"mo", output:"\u03A0", tex:null, ttype:CONST},
{input:"psi",    tag:"mi", output:"\u03C8", tex:null, ttype:CONST},
{input:"Psi",    tag:"mi", output:"\u03A8", tex:null, ttype:CONST},
{input:"rho",    tag:"mi", output:"\u03C1", tex:null, ttype:CONST},
{input:"sigma",  tag:"mi", output:"\u03C3", tex:null, ttype:CONST},
{input:"Sigma",  tag:"mo", output:"\u03A3", tex:null, ttype:CONST},
{input:"tau",    tag:"mi", output:"\u03C4", tex:null, ttype:CONST},
{input:"theta",  tag:"mi", output:"\u03B8", tex:null, ttype:CONST},
{input:"vartheta", tag:"mi", output:"\u03D1", tex:null, ttype:CONST},
{input:"Theta",  tag:"mo", output:"\u0398", tex:null, ttype:CONST},
{input:"upsilon", tag:"mi", output:"\u03C5", tex:null, ttype:CONST},
{input:"xi",     tag:"mi", output:"\u03BE", tex:null, ttype:CONST},
{input:"Xi",     tag:"mo", output:"\u039E", tex:null, ttype:CONST},
{input:"zeta",   tag:"mi", output:"\u03B6", tex:null, ttype:CONST},

//binary operation symbols
{input:"*",  tag:"mo", output:"\u22C5", tex:"cdot", ttype:CONST},
{input:"**", tag:"mo", output:"\u22C6", tex:"star", ttype:CONST},
{input:"//", tag:"mo", output:"/",      tex:null, ttype:CONST},
{input:"\\\\", tag:"mo", output:"\\",   tex:"backslash", ttype:CONST},
{input:"setminus", tag:"mo", output:"\\", tex:null, ttype:CONST},
{input:"xx", tag:"mo", output:"\u00D7", tex:"times", ttype:CONST},
{input:"-:", tag:"mo", output:"\u00F7", tex:"divide", ttype:CONST},
{input:"@",  tag:"mo", output:"\u2218", tex:"circ", ttype:CONST},
{input:"o+", tag:"mo", output:"\u2295", tex:"oplus", ttype:CONST},
{input:"ox", tag:"mo", output:"\u2297", tex:"otimes", ttype:CONST},
{input:"o.", tag:"mo", output:"\u2299", tex:"odot", ttype:CONST},
{input:"sum", tag:"mo", output:"\u2211", tex:null, ttype:UNDEROVER},
{input:"prod", tag:"mo", output:"\u220F", tex:null, ttype:UNDEROVER},
{input:"^^",  tag:"mo", output:"\u2227", tex:"wedge", ttype:CONST},
{input:"^^^", tag:"mo", output:"\u22C0", tex:"bigwedge", ttype:UNDEROVER},
{input:"vv",  tag:"mo", output:"\u2228", tex:"vee", ttype:CONST},
{input:"vvv", tag:"mo", output:"\u22C1", tex:"bigvee", ttype:UNDEROVER},
{input:"nn",  tag:"mo", output:"\u2229", tex:"cap", ttype:CONST},
{input:"nnn", tag:"mo", output:"\u22C2", tex:"bigcap", ttype:UNDEROVER},
{input:"uu",  tag:"mo", output:"\u222A", tex:"cup", ttype:CONST},
{input:"uuu", tag:"mo", output:"\u22C3", tex:"bigcup", ttype:UNDEROVER},

//binary relation symbols
{input:"!=",  tag:"mo", output:"\u2260", tex:"ne", ttype:CONST},
{input:":=",  tag:"mo", output:":=",     tex:null, ttype:CONST},
{input:"lt",  tag:"mo", output:"<",      tex:null, ttype:CONST},
{input:"<=",  tag:"mo", output:"\u2264", tex:"le", ttype:CONST},
{input:"lt=", tag:"mo", output:"\u2264", tex:"leq", ttype:CONST},
{input:">=",  tag:"mo", output:"\u2265", tex:"ge", ttype:CONST},
{input:"geq", tag:"mo", output:"\u2265", tex:null, ttype:CONST},
{input:"-<",  tag:"mo", output:"\u227A", tex:"prec", ttype:CONST},
{input:"-lt", tag:"mo", output:"\u227A", tex:null, ttype:CONST},
{input:">-",  tag:"mo", output:"\u227B", tex:"succ", ttype:CONST},
{input:"-<=", tag:"mo", output:"\u2AAF", tex:"preceq", ttype:CONST},
{input:">-=", tag:"mo", output:"\u2AB0", tex:"succeq", ttype:CONST},
{input:"in",  tag:"mo", output:"\u2208", tex:null, ttype:CONST},
{input:"!in", tag:"mo", output:"\u2209", tex:"notin", ttype:CONST},
{input:"sub", tag:"mo", output:"\u2282", tex:"subset", ttype:CONST},
{input:"sup", tag:"mo", output:"\u2283", tex:"supset", ttype:CONST},
{input:"sube", tag:"mo", output:"\u2286", tex:"subseteq", ttype:CONST},
{input:"supe", tag:"mo", output:"\u2287", tex:"supseteq", ttype:CONST},
{input:"-=",  tag:"mo", output:"\u2261", tex:"equiv", ttype:CONST},
{input:"~=",  tag:"mo", output:"\u2245", tex:"cong", ttype:CONST},
{input:"~~",  tag:"mo", output:"\u2248", tex:"approx", ttype:CONST},
{input:"prop", tag:"mo", output:"\u221D", tex:"propto", ttype:CONST},

//logical symbols
{input:"and", tag:"mtext", output:"and", tex:null, ttype:SPACE},
{input:"or",  tag:"mtext", output:"or",  tex:null, ttype:SPACE},
{input:"not", tag:"mo", output:"\u00AC", tex:"neg", ttype:CONST},
{input:"=>",  tag:"mo", output:"\u21D2", tex:"implies", ttype:CONST},
{input:"if",  tag:"mo", output:"if",     tex:null, ttype:SPACE},
{input:"<=>", tag:"mo", output:"\u21D4", tex:"iff", ttype:CONST},
{input:"AA",  tag:"mo", output:"\u2200", tex:"forall", ttype:CONST},
{input:"EE",  tag:"mo", output:"\u2203", tex:"exists", ttype:CONST},
{input:"_|_", tag:"mo", output:"\u22A5", tex:"bot", ttype:CONST},
{input:"TT",  tag:"mo", output:"\u22A4", tex:"top", ttype:CONST},
{input:"|--",  tag:"mo", output:"\u22A2", tex:"vdash", ttype:CONST},
{input:"|==",  tag:"mo", output:"\u22A8", tex:"models", ttype:CONST},

//grouping brackets
{input:"(", tag:"mo", output:"(", tex:null, ttype:LEFTBRACKET},
{input:")", tag:"mo", output:")", tex:null, ttype:RIGHTBRACKET},
{input:"[", tag:"mo", output:"[", tex:null, ttype:LEFTBRACKET},
{input:"]", tag:"mo", output:"]", tex:null, ttype:RIGHTBRACKET},
{input:"{", tag:"mo", output:"{", tex:null, ttype:LEFTBRACKET},
{input:"}", tag:"mo", output:"}", tex:null, ttype:RIGHTBRACKET},
{input:"|", tag:"mo", output:"|", tex:null, ttype:LEFTRIGHT},
//{input:"||", tag:"mo", output:"||", tex:null, ttype:LEFTRIGHT},
{input:"(:", tag:"mo", output:"\u2329", tex:"langle", ttype:LEFTBRACKET},
{input:":)", tag:"mo", output:"\u232A", tex:"rangle", ttype:RIGHTBRACKET},
{input:"<<", tag:"mo", output:"\u2329", tex:null, ttype:LEFTBRACKET},
{input:">>", tag:"mo", output:"\u232A", tex:null, ttype:RIGHTBRACKET},
{input:"{:", tag:"mo", output:"{:", tex:null, ttype:LEFTBRACKET, invisible:true},
{input:":}", tag:"mo", output:":}", tex:null, ttype:RIGHTBRACKET, invisible:true},

//miscellaneous symbols
{input:"int",  tag:"mo", output:"\u222B", tex:null, ttype:CONST},
{input:"dx",   tag:"mi", output:"{:d x:}", tex:null, ttype:DEFINITION},
{input:"dy",   tag:"mi", output:"{:d y:}", tex:null, ttype:DEFINITION},
{input:"dz",   tag:"mi", output:"{:d z:}", tex:null, ttype:DEFINITION},
{input:"dt",   tag:"mi", output:"{:d t:}", tex:null, ttype:DEFINITION},
{input:"oint", tag:"mo", output:"\u222E", tex:null, ttype:CONST},
{input:"del",  tag:"mo", output:"\u2202", tex:"partial", ttype:CONST},
{input:"grad", tag:"mo", output:"\u2207", tex:"nabla", ttype:CONST},
{input:"+-",   tag:"mo", output:"\u00B1", tex:"pm", ttype:CONST},
{input:"O/",   tag:"mo", output:"\u2205", tex:"emptyset", ttype:CONST},
{input:"oo",   tag:"mo", output:"\u221E", tex:"infty", ttype:CONST},
{input:"aleph", tag:"mo", output:"\u2135", tex:null, ttype:CONST},
{input:"...",  tag:"mo", output:"...",    tex:"ldots", ttype:CONST},
{input:":.",  tag:"mo", output:"\u2234",  tex:"therefore", ttype:CONST},
{input:"/_",  tag:"mo", output:"\u2220",  tex:"angle", ttype:CONST},
{input:"\\ ",  tag:"mo", output:"\u00A0", tex:null, ttype:CONST},
{input:"quad", tag:"mo", output:"\u00A0\u00A0", tex:null, ttype:CONST},
{input:"qquad", tag:"mo", output:"\u00A0\u00A0\u00A0\u00A0", tex:null, ttype:CONST},
{input:"cdots", tag:"mo", output:"\u22EF", tex:null, ttype:CONST},
{input:"vdots", tag:"mo", output:"\u22EE", tex:null, ttype:CONST},
{input:"ddots", tag:"mo", output:"\u22F1", tex:null, ttype:CONST},
{input:"diamond", tag:"mo", output:"\u22C4", tex:null, ttype:CONST},
{input:"square", tag:"mo", output:"\u25A1", tex:null, ttype:CONST},
{input:"|__", tag:"mo", output:"\u230A",  tex:"lfloor", ttype:CONST},
{input:"__|", tag:"mo", output:"\u230B",  tex:"rfloor", ttype:CONST},
{input:"|~", tag:"mo", output:"\u2308",  tex:"lceiling", ttype:CONST},
{input:"~|", tag:"mo", output:"\u2309",  tex:"rceiling", ttype:CONST},
{input:"CC",  tag:"mo", output:"\u2102", tex:null, ttype:CONST},
{input:"NN",  tag:"mo", output:"\u2115", tex:null, ttype:CONST},
{input:"QQ",  tag:"mo", output:"\u211A", tex:null, ttype:CONST},
{input:"RR",  tag:"mo", output:"\u211D", tex:null, ttype:CONST},
{input:"ZZ",  tag:"mo", output:"\u2124", tex:null, ttype:CONST},
{input:"f",   tag:"mi", output:"f",      tex:null, ttype:UNARY, func:true},
{input:"g",   tag:"mi", output:"g",      tex:null, ttype:UNARY, func:true},

//standard functions
{input:"lim",  tag:"mo", output:"lim", tex:null, ttype:UNDEROVER},
{input:"Lim",  tag:"mo", output:"Lim", tex:null, ttype:UNDEROVER},
{input:"sin",  tag:"mo", output:"sin", tex:null, ttype:UNARY, func:true},
{input:"cos",  tag:"mo", output:"cos", tex:null, ttype:UNARY, func:true},
{input:"tan",  tag:"mo", output:"tan", tex:null, ttype:UNARY, func:true},
{input:"sinh", tag:"mo", output:"sinh", tex:null, ttype:UNARY, func:true},
{input:"cosh", tag:"mo", output:"cosh", tex:null, ttype:UNARY, func:true},
{input:"tanh", tag:"mo", output:"tanh", tex:null, ttype:UNARY, func:true},
{input:"cot",  tag:"mo", output:"cot", tex:null, ttype:UNARY, func:true},
{input:"sec",  tag:"mo", output:"sec", tex:null, ttype:UNARY, func:true},
{input:"csc",  tag:"mo", output:"csc", tex:null, ttype:UNARY, func:true},
{input:"log",  tag:"mo", output:"log", tex:null, ttype:UNARY, func:true},
{input:"ln",   tag:"mo", output:"ln",  tex:null, ttype:UNARY, func:true},
{input:"det",  tag:"mo", output:"det", tex:null, ttype:UNARY, func:true},
{input:"dim",  tag:"mo", output:"dim", tex:null, ttype:CONST},
{input:"mod",  tag:"mo", output:"mod", tex:null, ttype:CONST},
{input:"gcd",  tag:"mo", output:"gcd", tex:null, ttype:UNARY, func:true},
{input:"lcm",  tag:"mo", output:"lcm", tex:null, ttype:UNARY, func:true},
{input:"lub",  tag:"mo", output:"lub", tex:null, ttype:CONST},
{input:"glb",  tag:"mo", output:"glb", tex:null, ttype:CONST},
{input:"min",  tag:"mo", output:"min", tex:null, ttype:UNDEROVER},
{input:"max",  tag:"mo", output:"max", tex:null, ttype:UNDEROVER},

//arrows
{input:"uarr", tag:"mo", output:"\u2191", tex:"uparrow", ttype:CONST},
{input:"darr", tag:"mo", output:"\u2193", tex:"downarrow", ttype:CONST},
{input:"rarr", tag:"mo", output:"\u2192", tex:"rightarrow", ttype:CONST},
{input:"->",   tag:"mo", output:"\u2192", tex:"to", ttype:CONST},
{input:"|->",  tag:"mo", output:"\u21A6", tex:"mapsto", ttype:CONST},
{input:"larr", tag:"mo", output:"\u2190", tex:"leftarrow", ttype:CONST},
{input:"harr", tag:"mo", output:"\u2194", tex:"leftrightarrow", ttype:CONST},
{input:"rArr", tag:"mo", output:"\u21D2", tex:"Rightarrow", ttype:CONST},
{input:"lArr", tag:"mo", output:"\u21D0", tex:"Leftarrow", ttype:CONST},
{input:"hArr", tag:"mo", output:"\u21D4", tex:"Leftrightarrow", ttype:CONST},

//commands with argument
AMsqrt, AMroot, AMfrac, AMdiv, AMover, AMsub, AMsup,
{input:"hat", tag:"mover", output:"\u005E", tex:null, ttype:UNARY, acc:true},
{input:"bar", tag:"mover", output:"\u00AF", tex:"overline", ttype:UNARY, acc:true},
{input:"vec", tag:"mover", output:"\u2192", tex:null, ttype:UNARY, acc:true},
{input:"dot", tag:"mover", output:".",      tex:null, ttype:UNARY, acc:true},
{input:"ddot", tag:"mover", output:"..",    tex:null, ttype:UNARY, acc:true},
{input:"ul", tag:"munder", output:"\u0332", tex:"underline", ttype:UNARY, acc:true},
AMtext, AMmbox, AMquote,
{input:"bb", tag:"mstyle", atname:"fontweight", atval:"bold", output:"bb", tex:null, ttype:UNARY},
{input:"mathbf", tag:"mstyle", atname:"fontweight", atval:"bold", output:"mathbf", tex:null, ttype:UNARY},
{input:"sf", tag:"mstyle", atname:"fontfamily", atval:"sans-serif", output:"sf", tex:null, ttype:UNARY},
{input:"mathsf", tag:"mstyle", atname:"fontfamily", atval:"sans-serif", output:"mathsf", tex:null, ttype:UNARY},
{input:"bbb", tag:"mstyle", atname:"mathvariant", atval:"double-struck", output:"bbb", tex:null, ttype:UNARY, codes:AMbbb},
{input:"mathbb", tag:"mstyle", atname:"mathvariant", atval:"double-struck", output:"mathbb", tex:null, ttype:UNARY, codes:AMbbb},
{input:"cc",  tag:"mstyle", atname:"mathvariant", atval:"script", output:"cc", tex:null, ttype:UNARY, codes:AMcal},
{input:"mathcal", tag:"mstyle", atname:"mathvariant", atval:"script", output:"mathcal", tex:null, ttype:UNARY, codes:AMcal},
{input:"tt",  tag:"mstyle", atname:"fontfamily", atval:"monospace", output:"tt", tex:null, ttype:UNARY},
{input:"mathtt", tag:"mstyle", atname:"fontfamily", atval:"monospace", output:"mathtt", tex:null, ttype:UNARY},
{input:"fr",  tag:"mstyle", atname:"mathvariant", atval:"fraktur", output:"fr", tex:null, ttype:UNARY, codes:AMfrk},
{input:"mathfrak",  tag:"mstyle", atname:"mathvariant", atval:"fraktur", output:"mathfrak", tex:null, ttype:UNARY, codes:AMfrk}
];

function compareNames(s1,s2) {
  if (s1.input > s2.input) return 1
  else return -1;
}

var AMnames = []; //list of input symbols

function AMinitSymbols() {
  var texsymbols = [], i;
  for (i=0; i<AMsymbols.length; i++)
    if (AMsymbols[i].tex)
      texsymbols[texsymbols.length] = {input:AMsymbols[i].tex,
        tag:AMsymbols[i].tag, output:AMsymbols[i].output, ttype:AMsymbols[i].ttype};
  AMsymbols = AMsymbols.concat(texsymbols);
  AMsymbols.sort(compareNames);
  for (i=0; i<AMsymbols.length; i++) AMnames[i] = AMsymbols[i].input;
}

var AMmathml = "http://www.w3.org/1998/Math/MathML";

function AMcreateElementMathML(t) {
  if (isIE) return document.createElement("m:"+t);
  else return document.createElementNS(AMmathml,t);
}

function AMcreateMmlNode(t,frag) {
//  var node = AMcreateElementMathML(name);
  if (isIE) var node = document.createElement("m:"+t);
  else var node = document.createElementNS(AMmathml,t);
  node.appendChild(frag);
  return node;
}

function newcommand(oldstr,newstr) {
  AMsymbols = AMsymbols.concat([{input:oldstr, tag:"mo", output:newstr,
                                 tex:null, ttype:DEFINITION}]);
}

function AMremoveCharsAndBlanks(str,n) {
//remove n characters and any following blanks
  var st;
  if (str.charAt(n)=="\\" && str.charAt(n+1)!="\\" && str.charAt(n+1)!=" ")
    st = str.slice(n+1);
  else st = str.slice(n);
  for (var i=0; i<st.length && st.charCodeAt(i)<=32; i=i+1);
  return st.slice(i);
}

function AMposition(arr, str, n) {
// return position >=n where str appears or would be inserted
// assumes arr is sorted
  if (n==0) {
    var h,m;
    n = -1;
    h = arr.length;
    while (n+1<h) {
      m = (n+h) >> 1;
      if (arr[m]<str) n = m; else h = m;
    }
    return h;
  } else
    for (var i=n; i<arr.length && arr[i]<str; i++);
  return i; // i=arr.length || arr[i]>=str
}

function AMgetSymbol(str) {
//return maximal initial substring of str that appears in names
//return null if there is none
  var k = 0; //new pos
  var j = 0; //old pos
  var mk; //match pos
  var st;
  var tagst;
  var match = "";
  var more = true;
  for (var i=1; i<=str.length && more; i++) {
    st = str.slice(0,i); //initial substring of length i
    j = k;
    k = AMposition(AMnames, st, j);
    if (k<AMnames.length && str.slice(0,AMnames[k].length)==AMnames[k]){
      match = AMnames[k];
      mk = k;
      i = match.length;
    }
    more = k<AMnames.length && str.slice(0,AMnames[k].length)>=AMnames[k];
  }
  AMpreviousSymbol=AMcurrentSymbol;
  if (match!=""){
    AMcurrentSymbol=AMsymbols[mk].ttype;
    return AMsymbols[mk];
  }
// if str[0] is a digit or - return maxsubstring of digits.digits
  AMcurrentSymbol=CONST;
  k = 1;
  st = str.slice(0,1);
  var integ = true;
  while ("0"<=st && st<="9" && k<=str.length) {
    st = str.slice(k,k+1);
    k++;
  }
  if (st == decimalsign) {
    st = str.slice(k,k+1);
    if ("0"<=st && st<="9") {
      integ = false;
      k++;
      while ("0"<=st && st<="9" && k<=str.length) {
        st = str.slice(k,k+1);
        k++;
      }
    }
  }
  if ((integ && k>1) || k>2) {
    st = str.slice(0,k-1);
    tagst = "mn";
  } else {
    k = 2;
    st = str.slice(0,1); //take 1 character
    tagst = (("A">st || st>"Z") && ("a">st || st>"z")?"mo":"mi");
  }
  if (st=="-" && AMpreviousSymbol==INFIX) {
    AMcurrentSymbol = INFIX;  //trick "/" into recognizing "-" on second parse
    return {input:st, tag:tagst, output:st, ttype:UNARY, func:true};
  }
  return {input:st, tag:tagst, output:st, ttype:CONST};
}

function AMremoveBrackets(node) {
  var st;
  if (node.nodeName=="mrow") {
    st = node.firstChild.firstChild.nodeValue;
    if (st=="(" || st=="[" || st=="{") node.removeChild(node.firstChild);
  }
  if (node.nodeName=="mrow") {
    st = node.lastChild.firstChild.nodeValue;
    if (st==")" || st=="]" || st=="}") node.removeChild(node.lastChild);
  }
}

/*Parsing ASCII math expressions with the following grammar
v ::= [A-Za-z] | greek letters | numbers | other constant symbols
u ::= sqrt | text | bb | other unary symbols for font commands
b ::= frac | root | stackrel         binary symbols
l ::= ( | [ | { | (: | {:            left brackets
r ::= ) | ] | } | :) | :}            right brackets
S ::= v | lEr | uS | bSS             Simple expression
I ::= S_S | S^S | S_S^S | S          Intermediate expression
E ::= IE | I/I                       Expression
Each terminal symbol is translated into a corresponding mathml node.*/

var AMnestingDepth,AMpreviousSymbol,AMcurrentSymbol;

function AMparseSexpr(str) { //parses str and returns [node,tailstr]
  var symbol, node, result, i, st,// rightvert = false,
    newFrag = document.createDocumentFragment();
  str = AMremoveCharsAndBlanks(str,0);
  symbol = AMgetSymbol(str);             //either a token or a bracket or empty
  if (symbol == null || symbol.ttype == RIGHTBRACKET && AMnestingDepth > 0) {
    return [null,str];
  }
  if (symbol.ttype == DEFINITION) {
    str = symbol.output+AMremoveCharsAndBlanks(str,symbol.input.length);
    symbol = AMgetSymbol(str);
  }
  switch (symbol.ttype) {
  case UNDEROVER:
  case CONST:
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    return [AMcreateMmlNode(symbol.tag,        //its a constant
                             document.createTextNode(symbol.output)),str];
  case LEFTBRACKET:   //read (expr+)
    AMnestingDepth++;
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    result = AMparseExpr(str,true);
    AMnestingDepth--;
    if (typeof symbol.invisible == "boolean" && symbol.invisible)
      node = AMcreateMmlNode("mrow",result[0]);
    else {
      node = AMcreateMmlNode("mo",document.createTextNode(symbol.output));
      node = AMcreateMmlNode("mrow",node);
      node.appendChild(result[0]);
    }
    return [node,result[1]];
  case TEXT:
      if (symbol!=AMquote) str = AMremoveCharsAndBlanks(str,symbol.input.length);
      if (str.charAt(0)=="{") i=str.indexOf("}");
      else if (str.charAt(0)=="(") i=str.indexOf(")");
      else if (str.charAt(0)=="[") i=str.indexOf("]");
      else if (symbol==AMquote) i=str.slice(1).indexOf("\"")+1;
      else i = 0;
      if (i==-1) i = str.length;
      st = str.slice(1,i);
      if (st.charAt(0) == " ") {
        node = AMcreateElementMathML("mspace");
        node.setAttribute("width","1ex");
        newFrag.appendChild(node);
      }
      newFrag.appendChild(
        AMcreateMmlNode(symbol.tag,document.createTextNode(st)));
      if (st.charAt(st.length-1) == " ") {
        node = AMcreateElementMathML("mspace");
        node.setAttribute("width","1ex");
        newFrag.appendChild(node);
      }
      str = AMremoveCharsAndBlanks(str,i+1);
      return [AMcreateMmlNode("mrow",newFrag),str];
  case UNARY:
      str = AMremoveCharsAndBlanks(str,symbol.input.length);
      result = AMparseSexpr(str);
      if (result[0]==null) return [AMcreateMmlNode(symbol.tag,
                             document.createTextNode(symbol.output)),str];
      if (typeof symbol.func == "boolean" && symbol.func) { // functions hack
        st = str.charAt(0);
        if (st=="^" || st=="_" || st=="/" || st=="|" || st==",") {
          return [AMcreateMmlNode(symbol.tag,
                    document.createTextNode(symbol.output)),str];
        } else {
          node = AMcreateMmlNode("mrow",
           AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));
          node.appendChild(result[0]);
          return [node,result[1]];
        }
      }
      AMremoveBrackets(result[0]);
      if (symbol.input == "sqrt") {           // sqrt
        return [AMcreateMmlNode(symbol.tag,result[0]),result[1]];
      } else if (typeof symbol.acc == "boolean" && symbol.acc) {   // accent
        node = AMcreateMmlNode(symbol.tag,result[0]);
        node.appendChild(AMcreateMmlNode("mo",document.createTextNode(symbol.output)));
        return [node,result[1]];
      } else {                        // font change command
        if (!isIE && typeof symbol.codes != "undefined") {
          for (i=0; i<result[0].childNodes.length; i++)
            if (result[0].childNodes[i].nodeName=="mi" || result[0].nodeName=="mi") {
              st = (result[0].nodeName=="mi"?result[0].firstChild.nodeValue:
                              result[0].childNodes[i].firstChild.nodeValue);
              var newst = [];
              for (var j=0; j<st.length; j++)
                if (st.charCodeAt(j)>64 && st.charCodeAt(j)<91) newst = newst +
                  String.fromCharCode(symbol.codes[st.charCodeAt(j)-65]);
                else newst = newst + st.charAt(j);
              if (result[0].nodeName=="mi")
                result[0]=AMcreateElementMathML("mo").
                          appendChild(document.createTextNode(newst));
              else result[0].replaceChild(AMcreateElementMathML("mo").
          appendChild(document.createTextNode(newst)),result[0].childNodes[i]);
            }
        }
        node = AMcreateMmlNode(symbol.tag,result[0]);
        node.setAttribute(symbol.atname,symbol.atval);
        return [node,result[1]];
      }
  case BINARY:
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    result = AMparseSexpr(str);
    if (result[0]==null) return [AMcreateMmlNode("mo",
                           document.createTextNode(symbol.input)),str];
    AMremoveBrackets(result[0]);
    var result2 = AMparseSexpr(result[1]);
    if (result2[0]==null) return [AMcreateMmlNode("mo",
                           document.createTextNode(symbol.input)),str];
    AMremoveBrackets(result2[0]);
    if (symbol.input=="root" || symbol.input=="stackrel")
      newFrag.appendChild(result2[0]);
    newFrag.appendChild(result[0]);
    if (symbol.input=="frac") newFrag.appendChild(result2[0]);
    return [AMcreateMmlNode(symbol.tag,newFrag),result2[1]];
  case INFIX:
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    return [AMcreateMmlNode("mo",document.createTextNode(symbol.output)),str];
  case SPACE:
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    node = AMcreateElementMathML("mspace");
    node.setAttribute("width","1ex");
    newFrag.appendChild(node);
    newFrag.appendChild(
      AMcreateMmlNode(symbol.tag,document.createTextNode(symbol.output)));
    node = AMcreateElementMathML("mspace");
    node.setAttribute("width","1ex");
    newFrag.appendChild(node);
    return [AMcreateMmlNode("mrow",newFrag),str];
  case LEFTRIGHT:
//    if (rightvert) return [null,str]; else rightvert = true;
    AMnestingDepth++;
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    result = AMparseExpr(str,false);
    AMnestingDepth--;
    var st = "";
    if (result[0].lastChild!=null)
      st = result[0].lastChild.firstChild.nodeValue;
    if (st == "|") { // its an absolute value subterm
      node = AMcreateMmlNode("mo",document.createTextNode(symbol.output));
      node = AMcreateMmlNode("mrow",node);
      node.appendChild(result[0]);
      return [node,result[1]];
    } else { // the "|" is a \mid
      node = AMcreateMmlNode("mo",document.createTextNode(symbol.output));
      node = AMcreateMmlNode("mrow",node);
      return [node,str];
    }
  default:
//alert("default");
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    return [AMcreateMmlNode(symbol.tag,        //its a constant
                             document.createTextNode(symbol.output)),str];
  }
}

function AMparseIexpr(str) {
  var symbol, sym1, sym2, node, result, underover;
  str = AMremoveCharsAndBlanks(str,0);
  sym1 = AMgetSymbol(str);
  result = AMparseSexpr(str);
  node = result[0];
  str = result[1];
  symbol = AMgetSymbol(str);
  if (symbol.ttype == INFIX && symbol.input != "/") {
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
//    if (symbol.input == "/") result = AMparseIexpr(str); else ...
    result = AMparseSexpr(str);
    if (result[0] == null) // show box in place of missing argument
      result[0] = AMcreateMmlNode("mo",document.createTextNode("\u25A1"));
    else AMremoveBrackets(result[0]);
    str = result[1];
//    if (symbol.input == "/") AMremoveBrackets(node);
    if (symbol.input == "_") {
      sym2 = AMgetSymbol(str);
      underover = (sym1.ttype == UNDEROVER);
      if (sym2.input == "^") {
        str = AMremoveCharsAndBlanks(str,sym2.input.length);
        var res2 = AMparseSexpr(str);
        AMremoveBrackets(res2[0]);
        str = res2[1];
        node = AMcreateMmlNode((underover?"munderover":"msubsup"),node);
        node.appendChild(result[0]);
        node.appendChild(res2[0]);
        node = AMcreateMmlNode("mrow",node); // so sum does not stretch
      } else {
        node = AMcreateMmlNode((underover?"munder":"msub"),node);
        node.appendChild(result[0]);
      }
    } else {
      node = AMcreateMmlNode(symbol.tag,node);
      node.appendChild(result[0]);
    }
  }
  return [node,str];
}

function AMparseExpr(str,rightbracket) {
  var symbol, node, result, i, nodeList = [],
  newFrag = document.createDocumentFragment();
  do {
    str = AMremoveCharsAndBlanks(str,0);
    result = AMparseIexpr(str);
    node = result[0];
    str = result[1];
    symbol = AMgetSymbol(str);
    if (symbol.ttype == INFIX && symbol.input == "/") {
      str = AMremoveCharsAndBlanks(str,symbol.input.length);
      result = AMparseIexpr(str);
      if (result[0] == null) // show box in place of missing argument
        result[0] = AMcreateMmlNode("mo",document.createTextNode("\u25A1"));
      else AMremoveBrackets(result[0]);
      str = result[1];
      AMremoveBrackets(node);
      node = AMcreateMmlNode(symbol.tag,node);
      node.appendChild(result[0]);
      newFrag.appendChild(node);
      symbol = AMgetSymbol(str);
    }
    else if (node!=undefined) newFrag.appendChild(node);
  } while ((symbol.ttype != RIGHTBRACKET &&
           (symbol.ttype != LEFTRIGHT || rightbracket)
           || AMnestingDepth == 0) && symbol!=null && symbol.output!="");
  if (symbol.ttype == RIGHTBRACKET || symbol.ttype == LEFTRIGHT) {
//    if (AMnestingDepth > 0) AMnestingDepth--;
    var len = newFrag.childNodes.length;
    if (len>0 && newFrag.childNodes[len-1].nodeName == "mrow" && len>1 &&
      newFrag.childNodes[len-2].nodeName == "mo" &&
      newFrag.childNodes[len-2].firstChild.nodeValue == ",") { //matrix
      var right = newFrag.childNodes[len-1].lastChild.firstChild.nodeValue;
      if (right==")" || right=="]") {
        var left = newFrag.childNodes[len-1].firstChild.firstChild.nodeValue;
        if (left=="(" && right==")" && symbol.output != "}" ||
            left=="[" && right=="]") {
        var pos = []; // positions of commas
        var matrix = true;
        var m = newFrag.childNodes.length;
        for (i=0; matrix && i<m; i=i+2) {
          pos[i] = [];
          node = newFrag.childNodes[i];
          if (matrix) matrix = node.nodeName=="mrow" &&
            (i==m-1 || node.nextSibling.nodeName=="mo" &&
            node.nextSibling.firstChild.nodeValue==",")&&
            node.firstChild.firstChild.nodeValue==left &&
            node.lastChild.firstChild.nodeValue==right;
          if (matrix)
            for (var j=0; j<node.childNodes.length; j++)
              if (node.childNodes[j].firstChild.nodeValue==",")
                pos[i][pos[i].length]=j;
          if (matrix && i>1) matrix = pos[i].length == pos[i-2].length;
        }
        if (matrix) {
          var row, frag, n, k, table = document.createDocumentFragment();
          for (i=0; i<m; i=i+2) {
            row = document.createDocumentFragment();
            frag = document.createDocumentFragment();
            node = newFrag.firstChild; // <mrow>(-,-,...,-,-)</mrow>
            n = node.childNodes.length;
            k = 0;
            node.removeChild(node.firstChild); //remove (
            for (j=1; j<n-1; j++) {
              if (typeof pos[i][k] != "undefined" && j==pos[i][k]){
                node.removeChild(node.firstChild); //remove ,
                row.appendChild(AMcreateMmlNode("mtd",frag));
                k++;
              } else frag.appendChild(node.firstChild);
            }
            row.appendChild(AMcreateMmlNode("mtd",frag));
            if (newFrag.childNodes.length>2) {
              newFrag.removeChild(newFrag.firstChild); //remove <mrow>)</mrow>
              newFrag.removeChild(newFrag.firstChild); //remove <mo>,</mo>
            }
            table.appendChild(AMcreateMmlNode("mtr",row));
          }
          node = AMcreateMmlNode("mtable",table);
          if (typeof symbol.invisible == "boolean" && symbol.invisible) node.setAttribute("columnalign","left");
          newFrag.replaceChild(node,newFrag.firstChild);
        }
       }
      }
    }
    str = AMremoveCharsAndBlanks(str,symbol.input.length);
    if (typeof symbol.invisible != "boolean" || !symbol.invisible) {
      node = AMcreateMmlNode("mo",document.createTextNode(symbol.output));
      newFrag.appendChild(node);
    }
  }
  return [newFrag,str];
}

function AMparseMath(str) {
  var result, node = AMcreateElementMathML("mstyle");
  if (mathcolor != "") node.setAttribute("mathcolor",mathcolor);
  if (displaystyle) node.setAttribute("displaystyle","true");
  if (mathfontfamily != "") node.setAttribute("fontfamily",mathfontfamily);
  AMnestingDepth = 0;
  node.appendChild(AMparseExpr(str.replace(/^\s+/g,""),false)[0]);
  node = AMcreateMmlNode("math",node);
  if (showasciiformulaonhover)                      //fixed by djhsu so newline
    node.setAttribute("title",str.replace(/\s+/g," "));//does not show in Gecko
  if (mathfontfamily != "" && (isIE || mathfontfamily != "serif")) {
    var fnode = AMcreateElementXHTML("font");
    fnode.setAttribute("face",mathfontfamily);
    fnode.appendChild(node);
    return fnode;
  }
  return node;
}

function AMstrarr2docFrag(arr, linebreaks) {
  var newFrag=document.createDocumentFragment();
  var expr = false;
  for (var i=0; i<arr.length; i++) {
    if (expr) newFrag.appendChild(AMparseMath(arr[i]));
    else {
      var arri = (linebreaks ? arr[i].split("\n\n") : [arr[i]]);
      newFrag.appendChild(AMcreateElementXHTML("span").
      appendChild(document.createTextNode(arri[0])));
      for (var j=1; j<arri.length; j++) {
        newFrag.appendChild(AMcreateElementXHTML("p"));
        newFrag.appendChild(AMcreateElementXHTML("span").
        appendChild(document.createTextNode(arri[j])));
      }
    }
    expr = !expr;
  }
  return newFrag;
}

function AMprocessNodeR(n, linebreaks) {
  var mtch, str, arr, frg, i;
  if (n.childNodes.length == 0) {
   if ((n.nodeType!=8 || linebreaks) &&
    n.parentNode.nodeName!="form" && n.parentNode.nodeName!="FORM" &&
    n.parentNode.nodeName!="textarea" && n.parentNode.nodeName!="TEXTAREA" &&
    n.parentNode.nodeName!="pre" && n.parentNode.nodeName!="PRE") {
    str = n.nodeValue;
    if (!(str == null)) {
      str = str.replace(/\r\n\r\n/g,"\n\n");
      if (doubleblankmathdelimiter) {
        str = str.replace(/\x20\x20\./g," "+AMdelimiter1+".");
        str = str.replace(/\x20\x20,/g," "+AMdelimiter1+",");
        str = str.replace(/\x20\x20/g," "+AMdelimiter1+" ");
      }
      str = str.replace(/\x20+/g," ");
      str = str.replace(/\s*\r\n/g," ");
      mtch = false;
      str = str.replace(new RegExp(AMescape2, "g"),
              function(st){mtch=true;return "AMescape2"});
      str = str.replace(new RegExp(AMescape1, "g"),
              function(st){mtch=true;return "AMescape1"});
      str = str.replace(new RegExp(AMdelimiter2regexp, "g"),AMdelimiter1);
      arr = str.split(AMdelimiter1);
      for (i=0; i<arr.length; i++)
        arr[i]=arr[i].replace(/AMescape2/g,AMdelimiter2).
                      replace(/AMescape1/g,AMdelimiter1);
      if (arr.length>1 || mtch) {
        if (checkForMathML) {
          checkForMathML = false;
          var nd = AMisMathMLavailable();
          AMnoMathML = nd != null;
          if (AMnoMathML && notifyIfNoMathML)
            if (alertIfNoMathML)
              alert("To view the ASCIIMathML notation use Internet Explorer 6 +\nMathPlayer (free from www.dessci.com)\n\
                or Firefox/Mozilla/Netscape");
            else AMbody.insertBefore(nd,AMbody.childNodes[0]);
        }
        if (!AMnoMathML) {
          frg = AMstrarr2docFrag(arr,n.nodeType==8);
          var len = frg.childNodes.length;
          n.parentNode.replaceChild(frg,n);
          return len-1;
        } else return 0;
      }
    }
   } else return 0;
  } else if (n.nodeName!="math") {
    for (i=0; i<n.childNodes.length; i++)
      i += AMprocessNodeR(n.childNodes[i], linebreaks);
  }
  return 0;
}

function AMprocessNode(n, linebreaks, spanclassAM) {
  var frag,st;
  if (spanclassAM!=null) {
    frag = document.getElementsByTagName("span")
    for (var i=0;i<frag.length;i++)
      if (frag[i].className == "AM")
        AMprocessNodeR(frag[i],linebreaks);
  } else {
    try {
      st = n.innerHTML;
    } catch(err) {}
    if (st==null ||
        st.indexOf(AMdelimiter1)!=-1 || st.indexOf(AMdelimiter2)!=-1)
      AMprocessNodeR(n,linebreaks);
  }
  if (isIE) { //needed to match size and font of formula to surrounding text
    frag = document.getElementsByTagName('math');
    for (var i=0;i<frag.length;i++) frag[i].update()
  }
}

var AMbody;
var AMnoMathML = false, AMtranslated = false;

function translate(spanclassAM) {
  if (!AMtranslated) { // run this only once
    AMtranslated = true;
    AMinitSymbols();
    AMbody = document.getElementsByTagName("body")[0];
    AMprocessNode(AMbody, false, spanclassAM);
  }
}

if (isIE) { // avoid adding MathPlayer info explicitly to each webpage
  document.write("<object id=\"mathplayer\"\
  classid=\"clsid:32F66A20-7614-11D4-BD11-00104BD3F987\"></object>");
  document.write("<?import namespace=\"m\" implementation=\"#mathplayer\"?>");
}

// GO1.1 Generic onload by Brothercake
// http://www.brothercake.com/
//onload function (replaces the onload="translate()" in the <body> tag)
function generic()
{
  translate();
};
//setup onload function
if(typeof window.addEventListener != 'undefined')
{
  //.. gecko, safari, konqueror and standard
  window.addEventListener('load', generic, false);
}
else if(typeof document.addEventListener != 'undefined')
{
  //.. opera 7
  document.addEventListener('load', generic, false);
}
else if(typeof window.attachEvent != 'undefined')
{
  //.. win/ie
  window.attachEvent('onload', generic);
}
//** remove this condition to degrade older browsers
else
{
  //.. mac/ie5 and anything else that gets this far
  //if there's an existing onload function
  if(typeof window.onload == 'function')
  {
    //store it
    var existing = onload;
    //add new onload handler
    window.onload = function()
    {
      //call existing onload function
      existing();
      //call generic onload function
      generic();
    };
  }
  else
  {
    //setup onload function
    window.onload = generic;
  }
}
/*]]>*/
</script>
<style>
body {
 /* Show logos before asciidoc title. */
 background-image: url("images/SPIR_Nov14.svg"), url("images/Khronos_RGB_June18.svg");
 background-size: 525px 125px, 525px 125px;
 background-repeat: no-repeat, no-repeat;
 background-position: center 0px, center 125px;
 /* And margin-top so the logo is not covered by the asciidoc title. */
 margin-top: 250px;
}
</style>

</head>
<body class="article">
<div id="header">
<h1>SPIR-V Extended Instructions for GLSL</h1>
<span id="author">John Kessenich, Google</span><br>
<span id="revnumber">version 1.00, Revision 12</span>
</div>
<div id="content">
<div id="preamble">
<div class="sectionbody">
<div class="paragraph"><p>&#169; Copyright 2014-2020 The Khronos Group Inc. All Rights Reserved.</p></div>
<div class="paragraph"><p>This specification is protected by copyright laws and contains material proprietary to the Khronos Group, Inc. It or any components may not be reproduced, republished, distributed, transmitted, displayed, broadcast, or otherwise exploited in any manner
without the express prior written permission of Khronos Group. You may use this specification for implementing the functionality therein, without altering or removing any trademark, copyright or other notice from the specification, but the receipt or
possession of this specification does not convey any rights to reproduce, disclose, or distribute its contents, or to manufacture,
use, or sell anything that it may describe, in whole or in part.</p></div>
<div class="paragraph"><p>Khronos Group grants express permission to any current Promoter, Contributor or Adopter member of Khronos to copy and
redistribute UNMODIFIED versions of this specification in any fashion, provided that NO CHARGE is made for the specification
and the latest available update of the specification for any version of the API is used whenever possible. Such distributed
specification may be reformatted AS LONG AS the contents of the specification are not changed in any way. The specification
may be incorporated into a product that is sold as long as such product includes significant independent work developed by the
seller. A link to the current version of this specification on the Khronos Group website should be included whenever possible
with specification distributions.</p></div>
<div class="paragraph"><p>Khronos Group makes no, and expressly disclaims any, representations or warranties, express or implied, regarding this specification, including, without limitation, any implied warranties of merchantability or fitness for a particular purpose or noninfringement of any intellectual property. Khronos Group makes no, and expressly disclaims any, warranties, express or implied,
regarding the correctness, accuracy, completeness, timeliness, and reliability of the specification. Under no circumstances will
the Khronos Group, or any of its Promoters, Contributors or Members or their respective partners, officers, directors, employees,
agents, or representatives be liable for any damages, whether direct, indirect, special or consequential damages for lost revenues,
lost profits, or otherwise, arising from or in connection with these materials.
Khronos, SYCL, SPIR, WebGL, EGL, COLLADA, StreamInput, OpenVX, OpenKCam, glTF, OpenKODE, OpenVG, OpenWF,
OpenSL ES, OpenMAX, OpenMAX AL, OpenMAX IL and OpenMAX DL are trademarks and WebCL is a certification mark
of the Khronos Group Inc. OpenCL is a trademark of Apple Inc. and OpenGL and OpenML are registered trademarks and the
OpenGL ES and OpenGL SC logos are trademarks of Silicon Graphics International used under license by Khronos. All other
product names, trademarks, and/or company names are used solely for identification and belong to their respective owners.</p></div>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>This specifies the GLSL.std.450 extended instruction set. It provides instructions for the GLSL built-in functions that do not directly map to native SPIR-V instructions.</p></div>
<div class="paragraph"><p>Import this extended instruction set using an <strong>OpExtInstImport</strong> "GLSL.std.450" instruction.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="_binary_form">2. Binary Form</h2>
<div class="sectionbody">
<h3 id="_documentation_form_for_each_extended_instruction" class="float">Documentation form for each extended instruction:</h3>
<table class="tableblock frame-all grid-all"
style="
width:70%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>Extended Instruction Name</strong></p>
<p class="tableblock">Instruction description.</p>
<p class="tableblock"><em>Result Type</em> will describe the <em>Result Type</em> for the <strong>OpExtInst</strong> instruction.</p>
<p class="tableblock"><em>Number</em> is the extended instruction number to use in the <strong>OpExtInst</strong> instruction.</p>
<p class="tableblock"><em>Operand 1</em>, <em>Operand 2</em>,&#8230; are the operands listed for the <strong>OpExtInst</strong> instruction.</p>
<p class="tableblock">Any <strong>Capability</strong> restrictions.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>Number</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>Operand 1</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>Operand 2</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock">&#8230;</p></td>
</tr>
</tbody>
</table>
<h3 id="_extended_instructions" class="float">Extended instructions:</h3>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Round</strong><br>
<br>
Result is the value equal to the nearest whole number to <em>x</em>. The fraction 0.5 rounds in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that <strong>Round</strong> <em>x</em> is the same value as <strong>RoundEven</strong> <em>x</em> for all values of <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>RoundEven</strong><br>
<br>
Result is the value equal to the nearest whole number to <em>x</em>. A fractional part of 0.5 rounds toward the nearest even whole number. (Both 3.5 and 4.5 for <em>x</em> round to 4.0.)<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Trunc</strong><br>
<br>
Result is the value equal to the nearest whole number to <em>x</em> whose absolute value is not larger than the absolute value of <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:92%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FAbs</strong><br>
<br>
Result is <em>+0.0</em> if <em>x</em> is <em>&plusmn;0.0</em>, <em>x</em> if <em>x &gt; 0.0</em>, and <em>-x</em> if <em>x &lt; 0.0</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>SAbs</strong><br>
<br>
Result is <em>x</em> if <em>x &ge; 0</em>; otherwise result is -<em>x</em>, where <em>x</em> is interpreted as a signed integer.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br>
<br>
This instruction can be decorated with <strong>NoSignedWrap</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FSign</strong><br>
<br>
Result is <em>1.0</em> if <em>x &gt; 0</em>, <em>-1.0</em> if <em>x &lt; 0</em>, <em>+0.0</em> if <em>x = +0.0</em>, and <em>&plusmn;0.0</em> if <em>x = -0.0</em>. If <em>x</em> = <em>&plusmn;NaN</em>, the result can be any of &plusmn;1.0 or &plusmn;0.0, regardless of whether shader_float_controls is in use.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>SSign</strong><br>
<br>
Result is 1 if <em>x &gt; 0</em>, <em>0</em> if <em>x = 0</em>, or <em>-1</em> if <em>x &lt; 0</em>, where <em>x</em> is interpreted as a signed integer.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:92%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Floor</strong><br>
<br>
Result is the value equal to the nearest whole number that is less than or equal to <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:93%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Ceil</strong><br>
<br>
Result is the value equal to the nearest whole number that is greater than or equal to <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">9</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:72%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Fract</strong><br>
<br>
Result is <em>x</em> - <strong>floor</strong> <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">10</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:97%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Radians</strong><br>
<br>
Converts <em>degrees</em> to radians, i.e., <em>degrees</em> * &#960; / 180.<br>
<br>
 The operand <em>degrees</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>degrees</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">11</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>degrees</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:97%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Degrees</strong><br>
<br>
Converts <em>radians</em> to degrees, i.e., <em>radians</em> * 180 / &#960;.<br>
<br>
 The operand <em>radians</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>radians</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">12</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>radians</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:88%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Sin</strong><br>
<br>
The standard trigonometric sine of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">13</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:89%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Cos</strong><br>
<br>
The standard trigonometric cosine of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">14</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:89%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Tan</strong><br>
<br>
The standard trigonometric tangent of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">15</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Asin</strong><br>
<br>
Arc sine. Result is an angle, in radians, whose sine is <em>x</em>. The range of result values is [-&#960; / 2, &#960; / 2]. The resulting value is undefined if <strong>abs</strong> <em>x</em> &gt; 1.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">16</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Acos</strong><br>
<br>
Arc cosine. Result is an angle, in radians, whose cosine is <em>x</em>. The range of result values is [0, &#960;]. The resulting value is undefined if <strong>abs</strong> <em>x</em> &gt; 1.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">17</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Atan</strong><br>
<br>
Arc tangent. Result is an angle, in radians, whose tangent is <em>y_over_x</em>. The range of result values is [-&#960; / 2, &#960; / 2].<br>
<br>
 The operand <em>y_over_x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>y_over_x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">18</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y_over_x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:83%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Sinh</strong><br>
<br>
Hyperbolic sine of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">19</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:83%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Cosh</strong><br>
<br>
Hyperbolic cosine of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">20</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:84%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Tanh</strong><br>
<br>
Hyperbolic tangent of <em>x</em> radians.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">21</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:90%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Asinh</strong><br>
<br>
Arc hyperbolic sine; result is the inverse of <strong>sinh</strong>.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">22</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Acosh</strong><br>
<br>
Arc hyperbolic cosine; Result is the non-negative inverse of <strong>cosh</strong>. The resulting value is undefined if <em>x</em> &lt; 1.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">23</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Atanh</strong><br>
<br>
Arc hyperbolic tangent; result is the inverse of tanh. The resulting value is undefined if <strong>abs</strong> <em>x</em> &ge; 1.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">24</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Atan2</strong><br>
<br>
Arc tangent. Result is an angle, in radians, whose tangent is <em>y</em> / <em>x</em>. The signs of <em>x</em> and <em>y</em> are used to determine what quadrant the angle is in. The range of result values is  [-&#960;, &#960;]. The resulting value is undefined if <em>x</em> and <em>y</em> are both 0.<br>
<br>
 The operand <em>x</em> and <em>y</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">25</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Pow</strong><br>
<br>
Result is <em>x</em> raised to the <em>y</em> power; <em>x</em><sup><em>y</em></sup>. The resulting value is undefined if <em>x</em> &lt; 0. Result is undefined if <em>x</em> = 0 and <em>y</em> &le; 0.<br>
<br>
 The operand <em>x</em> and <em>y</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">26</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:90%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Exp</strong><br>
<br>
Result is the natural exponentiation of <em>x</em>; <em>e</em><sup><em>x</em></sup>.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">27</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Log</strong><br>
<br>
Result is the natural logarithm of <em>x</em>, i.e., the value <em>y</em> which satisfies the equation <em>x</em> = <em>e</em><sup><em>y</em></sup>. The resulting value is undefined if <em>x</em> &le; 0.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">28</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:87%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Exp2</strong><br>
<br>
Result is 2 raised to the <em>x</em> power; 2<sup><em>x</em></sup>.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">29</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Log2</strong><br>
<br>
Result is the base-2 logarithm of <em>x</em>, i.e., the value <em>y</em> which satisfies the equation  <em>x</em> = 2<sup><em>y</em></sup>. The resulting value is undefined if <em>x</em> &le; 0.<br>
<br>
 The operand <em>x</em> must be a              scalar or vector whose component type is 16-bit or 32-bit floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">30</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:88%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Sqrt</strong><br>
<br>
Result is the square root of <em>x</em>. The resulting value is undefined if <em>x</em> &lt; 0.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">31</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:91%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>InverseSqrt</strong><br>
<br>
Result is the reciprocal of <strong>sqrt</strong> <em>x</em>. The resulting value is undefined if <em>x</em> &le; 0.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">32</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:55%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Determinant</strong><br>
<br>
Result is the determinant of <em>x</em>.<br>
<br>
The operand <em>x</em> must be a square matrix.<br>
<br>
<em>Result Type</em> must be the same type as the component type in the columns of <em>x</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">33</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:83%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>MatrixInverse</strong><br>
<br>
Result is a matrix that is the inverse of <em>x</em>. The resulting values are undefined if <em>x</em> is singular or poorly conditioned (nearly singular).<br>
<br>
The operand <em>x</em> must be a square matrix.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">34</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Modf</strong><br>
<br>
<strong>Modf</strong> is deprecated, use <strong>ModfStruct</strong> instead.<br>
<br>
Result is the fractional part of <em>x</em>, and stores through <em>i</em> the whole-number part as a whole-number floating-point value. Both the result and the output parameter have the same sign as <em>x</em>.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
The operand <em>i</em> must have a pointer type.<br>
<br>
<em>Result Type</em>, the type of <em>x</em>, and the type <em>i</em> points to must all be the same type and have a floating-point component type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">35</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>i</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>ModfStruct</strong><br>
<br>
Result is a structure containing both the fractional part of <em>x</em> and the whole number part of <em>x</em>.<br>
<br>
<em>Result Type</em> must be an <strong>OpTypeStruct</strong> with two members. Member 0 holds the fractional part. Member 1 holds the whole number part. Both members get the same sign as <em>x</em>. These two members and <em>x</em> must all be the same type. Results are computed per component.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">36</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>FMin</strong><br>
<br>
Result is <em>y</em> if <em>y</em> &lt; <em>x</em>, either <em>x</em> or <em>y</em> if both <em>x</em> and <em>y</em> are zeros, otherwise <em>x</em>. Which operand is the result is undefined if one of the operands is a NaN.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">37</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>UMin</strong><br>
<br>
Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as unsigned integers.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">38</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>SMin</strong><br>
<br>
Result is <em>y</em> if <em>y</em> &lt; <em>x</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as signed integers.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">39</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>FMax</strong><br>
<br>
Result is <em>y</em> if <em>x</em> &lt; <em>y</em>, either <em>x</em> or <em>y</em> if both <em>x</em> and <em>y</em> are zeros, otherwise <em>x</em>. Which operand is the result is undefined if one of the operands is a NaN.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">40</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>UMax</strong><br>
<br>
Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as unsigned integers.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">41</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>SMax</strong><br>
<br>
Result is <em>y</em> if <em>x</em> &lt; <em>y</em>; otherwise result is <em>x</em>, where <em>x</em> and <em>y</em> are interpreted as signed integers.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> and <em>y</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">42</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>FClamp</strong><br>
<br>
Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>). The resulting value is undefined if <em>minVal</em> &gt; <em>maxVal</em>. The semantics used by min() and max() are those of FMin and FMax.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">43</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>minVal</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>maxVal</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>UClamp</strong><br>
<br>
Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>), where <em>x</em>, <em>minVal</em> and <em>maxVal</em> are interpreted as unsigned integers. The resulting value is undefined if <em>minVal</em> &gt; <em>maxVal</em>.<br>
<br>
 <em>Result Type</em> and the type of the operands must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">44</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>minVal</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>maxVal</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>SClamp</strong><br>
<br>
Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>), where <em>x</em>, <em>minVal</em> and <em>maxVal</em> are interpreted as signed integers. The resulting value is undefined if <em>minVal</em> &gt; <em>maxVal</em>.<br>
<br>
 <em>Result Type</em> and the type of the operands must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">45</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>minVal</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>maxVal</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:91%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>FMix</strong><br>
<br>
Result is the linear blend of <em>x</em> and <em>y</em>, i.e., <em>x</em> * (1 - <em>a</em>) + <em>y</em> * <em>a</em>.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">46</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>a</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:84%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Step</strong><br>
<br>
Result is 0.0 if <em>x</em> &lt; <em>edge</em>; otherwise result is 1.0.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">48</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>edge</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>SmoothStep</strong><br>
<br>
Result is 0.0 if <em>x</em> &le; <em>edge0</em> and 1.0 if <em>x</em> &ge; <em>edge1</em> and performs smooth Hermite interpolation between 0 and 1 if <em>edge0</em> &lt; <em>x</em> &lt; <em>edge1</em>. This is equivalent to:<br>
<br>
<em>t</em> * <em>t</em> * (3 - 2 * <em>t</em>), where <em>t</em> = clamp ((<em>x</em> - <em>edge0</em>) / (<em>edge1</em> - <em>edge0</em>), 0, 1)<br>
<br>
The resulting value is undefined if <em>edge0</em> &ge; <em>edge1</em>.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">49</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>edge0</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>edge1</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>Fma</strong><br>
<br>
Computes <em>a</em> * <em>b</em> + <em>c</em>. In uses where this operation is decorated with <strong>NoContraction</strong>:<br>
<br>
- <strong>fma</strong> is considered a single operation, whereas the expression <em>a</em> * <em>b</em> + <em>c</em> is considered two operations.<br></p>
<p class="tableblock">- The precision of <strong>fma</strong> can differ from the precision of the expression <em>a</em> * <em>b</em> + <em>c</em>.<br></p>
<p class="tableblock">- <strong>fma</strong> is computed with the same precision as any other <strong>fma</strong> decorated with <strong>NoContraction</strong>, giving invariant results for the same input values of <em>a</em>, <em>b</em>, and <em>c</em>.<br>
<br>
Otherwise, in the absence of a <strong>NoContraction</strong> decoration, there are no special constraints on the number of operations or difference in precision between <strong>fma</strong> and the expression <em>a</em> * <em>b</em> +<em>c</em>.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">50</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>a</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>b</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>c</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Frexp</strong><br>
<br>
<strong>Frexp</strong> is deprecated, use <strong>FrexpStruct</strong> instead.<br>
<br>
Splits <em>x</em> into a floating-point significand in the range (-1.0, 0.5] or [0.5, 1.0) and an integral exponent of 2, such that:<br></p>
<p class="tableblock"><em>x</em> = <em>significand</em> * 2<sup><em>exponent</em></sup><br></p>
<p class="tableblock">The <em>significand</em> is the instruction result. An <em>x</em> of <em>-0.0</em> results in a significand <em>-0.0</em>, while an <em>x</em> of <em>0.0</em> results in <em>0.0</em>. For a floating-point value that is an infinity or is not a number, the significand is undefined.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
The exponent is returned through the pointer-parameter <em>exp</em>. The <em>exp</em> operand must be a pointer to a scalar or vector with integer component type, with 32-bit component width. The number of components in <em>x</em> and what <em>exp</em> points to must be the same. If <em>x</em> is a zero, the exponent is 0.0. If <em>x</em> is an infinity or a NaN, the exponent is undefined.<br>
<br>
<em>Result Type</em> must be the same type as the type of <em>x</em>. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">51</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>exp</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FrexpStruct</strong><br>
<br>
Result is a structure containing <em>x</em> split into a floating-point significand in the range (-1.0, 0.5] or [0.5, 1.0) and an integral exponent of 2, such that:<br></p>
<p class="tableblock"><em>x</em> = <em>significand</em> * 2<sup><em>exponent</em></sup><br></p>
<p class="tableblock">If <em>x</em> is a zero, the exponent is 0.0. If <em>x</em> is an infinity or a NaN, the exponent is undefined. If <em>x</em> is <em>0.0</em>, the significand is <em>0.0</em>. If <em>x</em> is <em>-0.0</em>, the significand is <em>-0.0</em><br>
<br>
<em>Result Type</em> must be an <strong>OpTypeStruct</strong> with two members.  Member 0 must have the same type as the type of <em>x</em>. Member 0 holds the significand. Member 1 must be a scalar or vector with integer component type, with 32-bit component width. Member 1 holds the exponent. These two members and <em>x</em> must have the same number of components.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">52</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Ldexp</strong><br>
<br>
Builds a floating-point number from <em>x</em> and the corresponding integral exponent of two in <em>exp</em>:<br></p>
<p class="tableblock"><em>significand</em> * 2<sup><em>exponent</em></sup><br></p>
<p class="tableblock">If this product is too large to be represented in the floating-point type, the resulting value is undefined. If <em>exp</em> is greater than +128 (single precision) or +1024 (double precision), the resulting value is undefined. If <em>exp</em> is less than -126 (single precision) or -1022 (double precision), the result may be flushed to zero. Additionally, splitting the value into a significand and exponent using <strong>frexp</strong> and then reconstructing a floating-point value using <strong>ldexp</strong> should yield the original input for zero and all finite non-denormalized values.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
The <em>exp</em> operand must be a scalar or vector with integer component type.  The number of components in <em>x</em> and <em>exp</em> must be the same.<br>
<br>
<em>Result Type</em> must be the same type as the type of <em>x</em>. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">53</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>exp</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackSnorm4x8</strong><br>
<br>
First, converts each component of the normalized floating-point value <em>v</em> into 8-bit integer values. These are then packed into the result.<br></p>
<p class="tableblock">The conversion for component <em>c</em> of <em>v</em> to fixed point is done as follows:<br></p>
<p class="tableblock">round(clamp(<em>c</em>, -1, +1) * 127.0)<br></p>
<p class="tableblock">The first component of the vector is written to the least significant bits of the output; the last component is written to the most significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 4 components whose type is a 32-bit floating-point.<br>
<br>
<em>Result Type</em> must be a 32-bit integer type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">54</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackUnorm4x8</strong><br>
<br>
First, converts each component of the normalized floating-point value <em>v</em> into 8-bit integer values. These are then packed into the result.<br></p>
<p class="tableblock">The conversion for component <em>c</em> of <em>v</em> to fixed point is done as follows:<br></p>
<p class="tableblock">round(clamp(<em>c</em>, 0, +1) * 255.0)<br></p>
<p class="tableblock">The first component of the vector is written to the least significant bits of the output; the last component is written to the most significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 4 components whose type is a 32-bit floating-point.<br>
<br>
<em>Result Type</em> must be a 32-bit integer type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">55</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackSnorm2x16</strong><br>
<br>
First, converts each component of the normalized floating-point value <em>v</em> into 16-bit integer values. These are then packed into the result.<br></p>
<p class="tableblock">The conversion for component <em>c</em> of <em>v</em> to fixed point is done as follows:<br></p>
<p class="tableblock">round(clamp(<em>c</em>, -1, +1) * 32767.0)<br></p>
<p class="tableblock">The first component of the vector is written to the least significant bits of the output; the last component is written to the most significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 2 components whose type is a 32-bit floating-point.<br>
<br>
<em>Result Type</em> must be a 32-bit integer type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">56</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackUnorm2x16</strong><br>
<br>
First, converts each component of the normalized floating-point value <em>v</em> into 16-bit integer values. These are then packed into the result.<br></p>
<p class="tableblock">The conversion for component <em>c</em> of <em>v</em> to fixed point is done as follows:<br></p>
<p class="tableblock">round(clamp(<em>c</em>, 0, +1) * 65535.0)<br></p>
<p class="tableblock">The first component of the vector is written to the least significant bits of the output; the last component is written to the most significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 2 components whose type is a 32-bit floating-point.<br>
<br>
<em>Result Type</em> must be a 32-bit integer type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">57</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackHalf2x16</strong><br>
<br>
Result is the unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit <strong>OpTypeFloat</strong>, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 2 components whose type is a 32-bit floating-point.<br>
<br>
<em>Result Type</em> must be a 32-bit integer type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">58</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>PackDouble2x32</strong><br>
<br>
Result is the double-precision value obtained by packing the components of <em>v</em> into a 64-bit value. If an IEEE 754 Inf or NaN is created, it will not signal, and the resulting floating-point value is unspecified. Otherwise, the bit-level representation of <em>v</em> is preserved. The first vector component specifies the 32 least significant bits; the second component specifies the 32 most significant bits.<br>
<br>
The <em>v</em> operand must be a vector of 2 components whose type is a 32-bit integer.<br>
<br>
<em>Result Type</em> must be a 64-bit floating-point scalar.<br>
<br>
Use of this instruction requires declaration of the <strong>Float64</strong> capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">59</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackSnorm2x16</strong><br>
<br>
First, unpacks a single 32-bit unsigned integer <em>p</em> into a pair of 16-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br></p>
<p class="tableblock">clamp(<em>f</em> / 32767.0, -1, +1)<br></p>
<p class="tableblock">The first component of the result is extracted from the least significant bits of the input; the last component is extracted from the most significant bits.<br>
<br>
The <em>p</em> operand must be a scalar with 32-bit integer type.<br>
<br>
<em>Result Type</em> must be a vector of 2 components whose type is 32-bit floating point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">60</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackUnorm2x16</strong><br>
<br>
First, unpacks a single 32-bit unsigned integer <em>p</em> into a pair of 16-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br></p>
<p class="tableblock"><em>f</em> / 65535.0<br></p>
<p class="tableblock">The first component of the result is extracted from the least significant bits of the input; the last component is extracted from the most significant bits.<br>
<br>
The <em>p</em> operand must be a scalar with 32-bit integer type.<br>
<br>
<em>Result Type</em> must be a vector of 2 components whose type is 32-bit floating point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">61</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackHalf2x16</strong><br>
<br>
Result is the two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. Subnormal numbers are either preserved or flushed to zero, consistently within an implemenation.<br></p>
<p class="tableblock"> The first component of the vector is obtained from the 16 least-significant bits of <em>v</em>; the second component is obtained from the 16 most-significant bits of <em>v</em>.<br>
<br>
The <em>v</em> operand must be a scalar with 32-bit integer type.<br>
<br>
<em>Result Type</em> must be a vector of 2 components whose type is 32-bit floating point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">62</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackSnorm4x8</strong><br>
<br>
First, unpacks a single 32-bit unsigned integer <em>p</em> into four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br></p>
<p class="tableblock">clamp(<em>f</em> / 127.0, -1, +1)<br></p>
<p class="tableblock">The first component of the result is extracted from the least significant bits of the input; the last component is extracted from the most significant bits.<br>
<br>
The <em>p</em> operand must be a scalar with 32-bit integer type.<br>
<br>
<em>Result Type</em> must be a vector of 4 components whose type is 32-bit floating point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">63</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackUnorm4x8</strong><br>
<br>
First, unpacks a single 32-bit unsigned integer <em>p</em> into four 8-bit unsigned integers. Then, each component is converted to a normalized floating-point value to generate the result. The conversion for unpacked fixed-point value <em>f</em> to floating point is done as follows:<br></p>
<p class="tableblock"><em>f</em> / 255.0<br></p>
<p class="tableblock">The first component of the result is extracted from the least significant bits of the input; the last component is extracted from the most significant bits.<br>
<br>
The <em>p</em> operand must be a scalar with 32-bit integer type.<br>
<br>
<em>Result Type</em> must be a vector of 4 components whose type is 32-bit floating point.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">64</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>UnpackDouble2x32</strong><br>
<br>
Result is the two-component unsigned integer vector representation of <em>v</em>. The bit-level representation of <em>v</em> is preserved. The first component of the vector contains the 32 least significant bits of the double; the second component consists of the 32 most significant bits.<br>
<br>
The <em>v</em> operand must be a scalar whose type is 64-bit floating point.<br>
<br>
<em>Result Type</em> must be a vector of 2 components whose type is a 32-bit integer.<br>
<br>
Use of this instruction requires declaration of the <strong>Float64</strong> capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">65</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>v</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:84%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Length</strong><br>
<br>
Result is the length of vector <em>x</em>, i.e., sqrt(<em>x</em> [0] <sup>2</sup> + <em>x</em> [1] <sup>2</sup> + &#8230;).<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
<em>Result Type</em> must be a scalar of the same type as the component type of <em>x</em>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">66</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:84%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Distance</strong><br>
<br>
Result is the distance between <em>p0</em> and <em>p1</em>, i.e., length(<em>p0</em> - <em>p1</em>).<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
<em>Result Type</em> must be a scalar of the same type as the component type of the operands.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">67</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p0</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>p1</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Cross</strong><br>
<br>
Result is the cross product of <em>x</em> and <em>y</em>, i.e., the resulting components are, in order:<br></p>
<p class="tableblock"><em>x</em>[1] * <em>y</em>[2] - <em>y</em>[1] * <em>x</em>[2]<br></p>
<p class="tableblock"><em>x</em>[2] * <em>y</em>[0] - <em>y</em>[2] * <em>x</em>[0]<br></p>
<p class="tableblock"><em>x</em>[0] * <em>y</em>[1] - <em>y</em>[0] * <em>x</em>[1]<br>
<br>
All the operands must be vectors of 3 components of a floating-point type.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">68</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:75%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>Normalize</strong><br>
<br>
Result is the vector in the same direction as <em>x</em> but with a length of 1.<br>
<br>
 The operand <em>x</em> must be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of <em>x</em> must be the same type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">69</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:84%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>FaceForward</strong><br>
<br>
If the dot product of <em>Nref</em> and <em>I</em> is negative, the result is <em>N</em>, otherwise it is <em>-N</em>.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">70</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>N</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>I</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Nref</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>Reflect</strong><br>
<br>
For the incident vector <em>I</em> and surface orientation <em>N</em>, the result is the reflection direction:<br></p>
<p class="tableblock"><em>I</em> - 2 * dot(<em>N</em>, <em>I</em>) * <em>N</em><br></p>
<p class="tableblock">This computation assumes <em>N</em> is already normalized.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">71</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>I</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>N</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>Refract</strong><br>
<br>
For the incident vector <em>I</em> and surface normal <em>N</em>, and the ratio of indices of refraction <em>eta</em>, the result is the refraction vector. The result is computed by<br></p>
<p class="tableblock">k = 1.0 - <em>eta</em> * <em>eta</em> * (1.0 - dot(<em>N</em>, <em>I</em>) * dot(<em>N</em>, <em>I</em>))<br></p>
<p class="tableblock">if k &lt; 0.0 the result is 0.0<br></p>
<p class="tableblock">otherwise, the result is <em>eta</em> * <em>I</em> - (<em>eta</em> * dot(<em>N</em>, <em>I</em>) + sqrt(k)) * <em>N</em><br></p>
<p class="tableblock">This computation assumes the input parameters for the incident vector <em>I</em> and the surface normal <em>N</em> are already normalized.<br>
<br>
The type of <em>I</em> and <em>N</em> must be a scalar or vector with a floating-point component type.<br>
<br>
The type of <em>eta</em> must be a floating-point scalar.<br>
<br>
<em>Result Type</em>, the type of <em>I</em>, the type of <em>N</em>, and the type of <em>eta</em> must all have the same component type.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">72</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>I</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>N</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>eta</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FindILsb</strong><br>
<br>
Integer least-significant bit.<br>
<br>
Results in the bit number of the least-significant 1-bit in the binary representation of <em>Value</em>. If <em>Value</em> is 0, the result has all bits set (e.g., -1 if interpreted as signed).<br>
<br>
 <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br>
<br>
This instruction is currently limited to 32-bit width components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">73</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Value</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FindSMsb</strong><br>
<br>
Signed-integer most-significant bit, with <em>Value</em> interpreted as a signed integer.<br>
<br>
For positive numbers, the result is the bit number of the most significant 1-bit. For negative numbers, the result is the bit number of the most significant 0-bit. For a <em>Value</em> of 0 or -1, the result has all bits set (e.g., -1 if interpreted as signed).<br>
<br>
 <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br>
<br>
This instruction is currently limited to 32-bit width components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">74</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Value</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>FindUMsb</strong><br>
<br>
Unsigned-integer most-significant bit.<br>
<br>
Results in the bit number of the most-significant 1-bit in the binary representation of <em>Value</em>. If <em>Value</em> is 0, the result has all bits set (e.g., -1 if interpreted as signed).<br>
<br>
 <em>Result Type</em> and the type of <em>Value</em> must both be integer scalar or integer vector types. <em>Result Type</em> and operand types must have the same number of components with the same component width. Results are computed per component.<br>
<br>
This instruction is currently limited to 32-bit width components.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">75</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>Value</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:50%;">
<col style="width:50%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="2" ><p class="tableblock"><strong>InterpolateAtCentroid</strong><br>
<br>
Result is the value of the input <em>interpolant</em> sampled at a location inside both the fragment and the primitive being processed. The value obtained would be the same value assigned to the input variable if it were decorated as <strong>Centroid</strong>.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br>
<br>
 This instruction is only valid in the <strong>Fragment</strong> execution model.<br>
<br>
 <em>Result Type</em> and the type that <em>interpolant</em> points to must be the same type.<br>
<br>
Use of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">76</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>interpolant</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>InterpolateAtSample</strong><br>
<br>
Result is the value of the input <em>interpolant</em> variable at the location of sample number <em>sample</em>. If sample <em>sample</em> does not exist, the position used to interpolate the input variable is undefined.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br>
<br>
 This instruction is only valid in the <strong>Fragment</strong> execution model.<br>
<br>
The <em>sample</em> operand must be a scalar 32-bit integer.<br>
<br>
 <em>Result Type</em> and the type that <em>interpolant</em> points to must be the same type.<br>
<br>
Use of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">77</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>interpolant</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>sample</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>InterpolateAtOffset</strong><br>
<br>
Result is the value of the input <em>interpolant</em> variable sampled at an offset from the center of the fragment specified by <em>offset</em>. The two floating-point components of <em>offset</em>, give the offset in pixels in the <em>x</em> and <em>y</em> directions, respectively. An <em>offset</em> of (0, 0) identifies the center of the fragment. The range and granularity of offsets supported are implementation-dependent.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to the <strong>Input</strong> Storage Class.<br>
<br>
 The operand <em>interpolant</em> must be a pointer to a scalar or vector whose component type is 32-bit floating-point.<br>
<br>
 This instruction is only valid in the <strong>Fragment</strong> execution model.<br>
<br>
The <em>offset</em> operand must be a vector of 2 components of 32-bit floating-point type.<br>
<br>
 <em>Result Type</em> and the type that <em>interpolant</em> points to must be the same type.<br>
<br>
Use of this instruction requires declaration of the <strong>InterpolationFunction</strong> capability.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">78</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>interpolant</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>offset</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>NMin</strong><br>
<br>
Result is <em>y</em> if <em>y</em> &lt; <em>x</em>, either <em>x</em> or <em>y</em> if both <em>x</em> and <em>y</em> are zeros, otherwise <em>x</em>. If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">79</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:33%;">
<col style="width:33%;">
<col style="width:33%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="3" ><p class="tableblock"><strong>NMax</strong><br>
<br>
Result is <em>y</em> if <em>x</em> &lt; <em>y</em>, either <em>x</em> or <em>y</em> if both <em>x</em> and <em>y</em> are zeros, otherwise <em>x</em>. If one operand is a NaN, the other operand is the result. If both operands are NaN, the result is a NaN.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">80</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>y</em></p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-all grid-all"
style="
width:100%;
">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<col style="width:25%;">
<tbody>
<tr>
<td class="tableblock halign-left valign-top" colspan="4" ><p class="tableblock"><strong>NClamp</strong><br>
<br>
Result is min(max(<em>x</em>, <em>minVal</em>), <em>maxVal</em>). The resulting value is undefined if <em>minVal</em> &gt; <em>maxVal</em>. The semantics used by min() and max() are those of NMin and NMax.<br>
<br>
 The operands must all be a scalar or vector whose component type is floating-point.<br>
<br>
 <em>Result Type</em> and the type of all operands must be the same type. Results are computed per component.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top" ><p class="tableblock">81</p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>x</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>minVal</em></p></td>
<td class="tableblock halign-left valign-top" ><p class="tableblock"><em>&lt;id&gt;</em><br>
<em>maxVal</em></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect1">
<h2 id="_appendix_a_changes">3. Appendix A: Changes</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_changes_from_version_0_99_revision_1">3.1. Changes from Version 0.99, Revision 1</h3>
<div class="ulist"><ul>
<li>
<p>
Fork the revision stream, changes section, etc. from the core specification, so this specification has its own, starting numbering at revision 1.
This document now lives independently.
</p>
</li>
<li>
<p>
Added integer versions of abs, sign, min, max, and clamp.
</p>
</li>
<li>
<p>
Removed floatBitsToInt, floatBitsToUint, intBitsToFloat, and uintBitsToFloat; these can be handled with <strong>OpBitcast</strong>.
</p>
</li>
<li>
<p>
Removed fTransform, not needed.
</p>
</li>
<li>
<p>
Fixed internal bugs
</p>
<div class="ulist"><ul>
<li>
<p>
13721: Add <strong>OpTypeStruct</strong>-result versions of <strong>Modf</strong> and <strong>Frexp</strong>: <strong>ModfStruct</strong> and <strong>FrexpStruct</strong>.
</p>
</li>
</ul></div>
</li>
<li>
<p>
Fixed public bugs
</p>
<div class="ulist"><ul>
<li>
<p>
1322: GLSL.std.450 frexp wasn&#8217;t saying the <em>exp</em> argument was a pointer to the result
</p>
</li>
</ul></div>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_0_99_revision_2">3.2. Changes from Version 0.99, Revision 2</h3>
<div class="ulist"><ul>
<li>
<p>
Moved AddCarry, SubBorrow, and MulExtended type of instructions to the core specification.
</p>
</li>
<li>
<p>
Added integer variant of <strong>Mix</strong>, creating <strong>FMix</strong> and <strong>IMix</strong> (14480).
</p>
</li>
<li>
<p>
Modified spellings to be more regular (14614).
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_0_99_revision_3">3.3. Changes from Version 0.99, Revision 3</h3>
<div class="ulist"><ul>
<li>
<p>
Add "<strong>N</strong>" version of <strong>Min</strong>, <strong>Max</strong>, and <strong>Clamp</strong>, creating a version that favors non-NaN operands over NaN operands.
</p>
</li>
<li>
<p>
Bug 15452 Remove <strong>IMix</strong>.
</p>
</li>
<li>
<p>
Bug 15300 Be more consistent that the <strong>InterpolateAt</strong> instructions take a pointer.
</p>
</li>
<li>
<p>
Bug 14548 Document the <strong>Capability</strong> needed for <strong>Double2x32</strong> and <strong>InterpolateAt</strong> instructions.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_1">3.4. Changes from Version 1.00, Revision 1</h3>
<div class="ulist"><ul>
<li>
<p>
Bug 14548 Document the <strong>Capability</strong> needed for <strong>UnpackDouble2x32</strong>.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_2">3.5. Changes from Version 1.00, Revision 2</h3>
<div class="ulist"><ul>
<li>
<p>
Change <strong>precise</strong> to <strong>NoContraction</strong>
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_3">3.6. Changes from Version 1.00, Revision 3</h3>
<div class="ulist"><ul>
<li>
<p>
Allow both 16-bit and 32-bit floating-point types in most places where before only 32-bit floating-point types were allowed.
  This does not effect whether 16-bit floating point types are allowed, which is selected independently.  Since 16-bit types
  were historically disallowed, this is a backward compatible change.
</p>
</li>
<li>
<p>
Fix Khronos internal issue #109: be more clear for NMin/NMax: If both operands are NaN, the result is a NaN.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_4">3.7. Changes from Version 1.00, Revision 4</h3>
<div class="ulist"><ul>
<li>
<p>
Be clear about <strong>UnpackHalf2x16</strong> denorm rules.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_5">3.8. Changes from Version 1.00, Revision 5</h3>
<div class="paragraph"><p>Fixed:</p></div>
<div class="ulist"><ul>
<li>
<p>
Khronos SPIR-V Issue #211: As with <strong>FindSMsb</strong> and <strong>FindUMsb</strong>, <strong>FindILsb</strong> needs 32-bit components.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_6">3.9. Changes from Version 1.00, Revision 6</h3>
<div class="paragraph"><p>Fixed:</p></div>
<div class="ulist"><ul>
<li>
<p>
Khronos SPIR-V Issue #337: The component types of the operands for <strong>Refract</strong> must all be the same.
</p>
</li>
<li>
<p>
Khronos SPIR-V Issue #331: Correct the types in <strong>ModfStruct</strong>.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_7">3.10. Changes from Version 1.00, Revision 7</h3>
<div class="paragraph"><p>Support SPV_KHR_no_integer_wrap_decoration, in the <strong>SAbs</strong> instruction.</p></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_8">3.11. Changes from Version 1.00, Revision 8</h3>
<div class="paragraph"><p>Fixed:</p></div>
<div class="ulist"><ul>
<li>
<p>
Khronos SPIR-V Issue #466: <strong>FAbs</strong> of <em>-0.0</em> is <em>+0.0</em>, <strong>FSign</strong> of <em>-0.0</em> can be either <em>&#177;0.0</em>.
  <strong>FMin</strong>, <strong>FMax</strong>, <strong>NMin</strong>, and <strong>NMax</strong> are allowed to return either operand when both are zeros.
</p>
</li>
<li>
<p>
Khronos SPIR-V Issue #458: For <strong>Frexp</strong>, be more clear about negative values, and also about which returned value is being discussed.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_9">3.12. Changes from Version 1.00, Revision 9</h3>
<div class="ulist"><ul>
<li>
<p>
Corrected the output range of <strong>Atan</strong>.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_10">3.13. Changes from Version 1.00, Revision 10</h3>
<div class="ulist"><ul>
<li>
<p>
State what <strong>FSign</strong> of <em>&plusmn;NaN</em> is.
</p>
</li>
</ul></div>
</div>
<div class="sect2">
<h3 id="_changes_from_version_1_00_revision_11">3.14. Changes from Version 1.00, Revision 11</h3>
<div class="ulist"><ul>
<li>
<p>
Khronos SPIR-V Issue #555: Deprecate <strong>Modf</strong>, use <strong>ModfStruct</strong> instead. Deprecate <strong>Frexp</strong>, use <strong>FrexpStruct</strong> instead.
</p>
</li>
<li>
<p>
Khronos SPIR-V Issue #284: Say all bits are set, instead of saying -1, for some results of <strong>FindILsb</strong>, <strong>FindSMsb</strong>, and <strong>FindUMsb</strong>.
</p>
</li>
<li>
<p>
Khronos SPIR-V MR #181: Use "fragment" instead of "pixel" in <strong>InterpolateAtCentroid</strong>, <strong>InterpolateAtSample</strong>, and <strong>InterpolateAtOffset</strong>.
</p>
</li>
</ul></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr></div>
<div id="footer">
<div id="footer-text">
Version 1.00, Revision 12<br>
Last updated 2020-10-21 12:44:39 MDT
</div>
</div>
</body>
</html>
